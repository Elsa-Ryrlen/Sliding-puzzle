<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Sliding Puzzle Game</title>
  <style>
    body {
      margin: 0;
      background: #111;
      font-family: Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      color: #fff;
    }

    #game-container {
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
    }
  </style>
</head>

<body>
  <div id="game-container"></div>

  <!-- Phaser 3 from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>

  <script>
    const TILE_SIZE = 100;
    const GRID_SIZE = 3;

    function makeTextButton(scene, x, y, label, onClick) {
      const paddingX = 18, paddingY = 10;

      const text = scene.add.text(0, 0, label, {
        fontFamily: 'Arial',
        fontSize: '22px',
        color: '#000000'
      }).setOrigin(0.5);

      const rect = scene.add.rectangle(0, 0,
        text.width + paddingX * 2,
        text.height + paddingY * 2,
        0xffffff
      ).setStrokeStyle(2, 0x000000);

      const container = scene.add.container(x, y, [rect, text]);
      container.setSize(rect.width, rect.height);
      container.setInteractive({ useHandCursor: true })
        .on('pointerover', () => rect.setFillStyle(0xdddddd))
        .on('pointerout', () => rect.setFillStyle(0xffffff))
        .on('pointerdown', onClick);

      return container;
    }

    class MenuScene extends Phaser.Scene {
      constructor() {
        super('MenuScene');
      }
      create() {
        const { width, height } = this.scale;

        this.add.rectangle(width / 2, height / 2, width, height, 0x222222);
        this.add.text(width / 2, 120, 'Sliding Puzzle', {
          fontFamily: 'Arial',
          fontSize: '36px',
          color: '#ffffff'
        }).setOrigin(0.5);

        makeTextButton(this, width / 2, 240, 'Start', () => {
          this.scene.start('SlidingPuzzleScene'); // <â€” change  
        });

        makeTextButton(this, width / 2, 300, 'Instructions', () => {
          this.scene.start('InstructionsScene');
        });

        this.add.text(width / 2, height - 24, 'Â© You â€¢ Phaser 3', {
          fontFamily: 'Arial',
          fontSize: '12px',
          color: '#bbbbbb'
        }).setOrigin(0.5);
      }
    }

    class InstructionsScene extends Phaser.Scene {
      constructor() {
        super('InstructionsScene');
      }
      create() {
        const { width, height } = this.scale;

        this.add.rectangle(width / 2, height / 2, width, height, 0x222222);

        this.add.text(width / 2, 90, 'How to Play', {
          fontFamily: 'Arial',
          fontSize: '32px',
          color: '#ffffff'
        }).setOrigin(0.5);

        const lines = [
          'Click a tile next to the empty space to move it.',
          'Rearrange the tiles into order 1..8 with the blank at the end.',
          'Tip: Solve row by row to make it easier.'
        ];
        this.add.text(width / 2, 180, lines.join('\n'), {
          fontFamily: 'Arial',
          fontSize: '18px',
          color: '#dddddd',
          align: 'center',
          wordWrap: { width: 420 }
        }).setOrigin(0.5);

        makeTextButton(this, width / 2, 360, 'Back to Menu', () => {
          this.scene.start('MenuScene');
        });

        makeTextButton(this, width / 2, 420, 'Play Now', () => {
          this.scene.start('SlidingPuzzleScene'); // <â€” change
        });
      }
    }

    class SlidingPuzzleScene extends Phaser.Scene {
      constructor() {
        super('SlidingPuzzleScene');
      }

      preload() {
        this.load.audio("tile-hit", "assets/audio/tile-hit.wav");
      }

      create() {
        const { width, height } = this.scale;

        this.tileSize = TILE_SIZE;
        this.gridSize = GRID_SIZE;
        this.offsetX = (width - this.tileSize * this.gridSize) / 2;
        this.offsetY = (height - this.tileSize * this.gridSize) / 2;

        // Build board dynamically based on grid size
        const totalTiles = this.gridSize * this.gridSize;
        this.board = [];
        for (let i = 1; i <= totalTiles - 1; i++) {
          this.board.push(i);
        }
        this.board.push(0); // 0 = blank
        this.blankIndex = totalTiles - 1;
        this.isAnimating = false;

        // Randomize board by doing valid moves from solved state
        this.shuffleBoard(200);

        // Draw background frame
        const frame = this.add.rectangle(
          width / 2,
          height / 2,
          this.tileSize * this.gridSize + 10,
          this.tileSize * this.gridSize + 10,
          0x333333
        );
        frame.setStrokeStyle(4, 0xffffff);

        // Create tiles based on shuffled board
        this.tileSprites = {};
        this.createTiles();
        makeTextButton(this, 70, 36, 'Menu', () => this.scene.start('MenuScene'));

        // Keyboard selection state
        this.movableIndices = [];
        this.selectedMovableIdx = -1;

        // Compute initial movable tiles & highlight
        this.updateSelectableTiles();

        // Victory text
        this.victoryText = this.add.text(
          width / 2,
          this.offsetY - 40,
          '',
          {
            fontFamily: 'Arial',
            fontSize: '28px',
            color: '#ffffff'
          }
        ).setOrigin(0.5);

        // Info text
        this.add.text(
          width / 2,
          height - 30,
          'Mouse: click tiles. Keyboard: J = cycle, K = move',
          {
            fontFamily: 'Arial',
            fontSize: '14px',
            color: '#bbbbbb'
          }
        ).setOrigin(0.5);

        this.input.keyboard.on('keydown-J', () => {
          if (this.isAnimating || this.input.enabled === false) return;
          this.cycleSelection();
        });

        this.input.keyboard.on('keydown-K', () => {
          if (this.isAnimating || this.input.enabled === false) return;
          this.moveSelectedTile();
        });
      }

      shuffleBoard(moves) {
        for (let i = 0; i < moves; i++) {
          const neighbors = this.getNeighborIndices(this.blankIndex);
          const target = Phaser.Utils.Array.GetRandom(neighbors);

          const temp = this.board[target];
          this.board[target] = this.board[this.blankIndex];
          this.board[this.blankIndex] = temp;
          this.blankIndex = target;
        }

        // Avoid trivial solved start
        if (this.isSolved()) {
          this.shuffleBoard(moves);
        }
      }

      createTiles() {
        const totalTiles = this.board.length;

        for (let index = 0; index < totalTiles; index++) {
          const value = this.board[index];
          if (value === 0) continue; // no sprite for blank

          const pos = this.indexToWorld(index);
          const container = this.add.container(pos.x, pos.y);

          const rect = this.add.rectangle(
            0,
            0,
            this.tileSize - 6,
            this.tileSize - 6,
            0xffffff
          );
          rect.setStrokeStyle(2, 0x000000);

          const text = this.add.text(
            0,
            0,
            value.toString(),
            {
              fontFamily: 'Arial',
              fontSize: '32px',
              color: '#000000'
            }
          ).setOrigin(0.5);

          container.add([rect, text]);
          container.setSize(this.tileSize - 6, this.tileSize - 6);
          container.setInteractive({ useHandCursor: true });
          container.tileNumber = value;
          container.bgRect = rect; // keep reference for highlight

          container.on('pointerdown', () => this.onTileClicked(container));

          this.tileSprites[value] = container;
        }
      }

      indexToWorld(index) {
        const row = Math.floor(index / this.gridSize);
        const col = index % this.gridSize;
        const x = this.offsetX + col * this.tileSize + this.tileSize / 2;
        const y = this.offsetY + row * this.tileSize + this.tileSize / 2;
        return { x, y };
      }

      getNeighborIndices(index) {
        const neighbors = [];
        const row = Math.floor(index / this.gridSize);
        const col = index % this.gridSize;

        if (row > 0) neighbors.push(index - this.gridSize);
        if (col < this.gridSize - 1) neighbors.push(index + 1);
        if (row < this.gridSize - 1) neighbors.push(index + this.gridSize);
        if (col > 0) neighbors.push(index - 1);

        return neighbors;
      }

      onTileClicked(tileContainer) {
        if (this.isAnimating || this.input.enabled === false) return;

        const tileNumber = tileContainer.tileNumber;
        const tileIndex = this.board.indexOf(tileNumber);
        const blankIndex = this.blankIndex;
        const neighbors = this.getNeighborIndices(blankIndex);

        // Only move if tile is adjacent to blank
        if (!neighbors.includes(tileIndex)) {
          return;
        }

        // If user clicked, also make this the selected movable tile
        const neighborIdxInList = neighbors.indexOf(tileIndex);
        if (neighborIdxInList !== -1) {
          this.movableIndices = neighbors;
          this.selectedMovableIdx = neighborIdxInList;
          this.updateSelectionHighlight();
        }

        this.performMove(tileContainer, tileIndex, blankIndex);
      }

      performMove(tileContainer, tileIndex, blankIndex) {
        this.isAnimating = true;
        const targetPos = this.indexToWorld(blankIndex);

        this.tweens.add({
          targets: tileContainer,
          x: targetPos.x,
          y: targetPos.y,
          duration: 150,
          onComplete: () => {
            // Swap in board state
            const tileNumber = tileContainer.tileNumber;
            this.board[blankIndex] = tileNumber;
            this.board[tileIndex] = 0;
            this.blankIndex = tileIndex;

            this.isAnimating = false;

            this.sound.play("tile-hit");

            if (this.isSolved()) {
              this.showVictory();
            } else {
              // Recompute movable tiles and keep keyboard navigation working
              this.updateSelectableTiles();
            }
          }
        });
      }

      isSolved() {
        const totalTiles = this.gridSize * this.gridSize;
        for (let i = 0; i < totalTiles - 1; i++) {
          if (this.board[i] !== i + 1) {
            return false;
          }
        }
        return this.board[totalTiles - 1] === 0;
      }

      showVictory() {
        this.victoryText.setText('Solved! ðŸŽ‰');
        this.input.enabled = false;
        this.clearSelectionHighlight();
      }

      // ---- Keyboard selection helpers ----

      updateSelectableTiles() {
        const neighbors = this.getNeighborIndices(this.blankIndex)
          .filter(i => this.board[i] !== 0); // should be redundant but safe

        const oldSelectedTileNumber = this.getSelectedTileNumber();

        this.movableIndices = neighbors;

        if (neighbors.length === 0) {
          this.selectedMovableIdx = -1;
          this.clearSelectionHighlight();
          return;
        }

        // Try to keep selection on same tile if still movable
        let newIndex = 0;
        if (oldSelectedTileNumber !== null) {
          for (let i = 0; i < neighbors.length; i++) {
            if (this.board[neighbors[i]] === oldSelectedTileNumber) {
              newIndex = i;
              break;
            }
          }
        }

        this.selectedMovableIdx = newIndex;
        this.updateSelectionHighlight();
      }

      getSelectedTileNumber() {
        if (this.selectedMovableIdx < 0 || this.selectedMovableIdx >= this.movableIndices.length) {
          return null;
        }
        const tileIndex = this.movableIndices[this.selectedMovableIdx];
        return this.board[tileIndex];
      }

      cycleSelection() {
        if (!this.movableIndices || this.movableIndices.length === 0) return;

        this.selectedMovableIdx = (this.selectedMovableIdx + 1) % this.movableIndices.length;
        this.updateSelectionHighlight();
      }

      moveSelectedTile() {
        const tileNumber = this.getSelectedTileNumber();
        if (tileNumber == null) return;

        const tileIndex = this.board.indexOf(tileNumber);
        const blankIndex = this.blankIndex;

        if (tileIndex === -1) return;

        const neighbors = this.getNeighborIndices(blankIndex);
        if (!neighbors.includes(tileIndex)) return; // safety check

        const container = this.tileSprites[tileNumber];
        this.performMove(container, tileIndex, blankIndex);
      }

      clearSelectionHighlight() {
        for (const key in this.tileSprites) {
          const c = this.tileSprites[key];
          if (c && c.bgRect) {
            c.bgRect.setFillStyle(0xffffff);
            c.bgRect.setStrokeStyle(2, 0x000000);
            c.setScale(1);
          }
        }
      }

      updateSelectionHighlight() {
        this.clearSelectionHighlight();

        const tileNumber = this.getSelectedTileNumber();
        if (tileNumber == null) return;

        const container = this.tileSprites[tileNumber];
        if (container && container.bgRect) {
          container.bgRect.setFillStyle(0xffee99);
          container.bgRect.setStrokeStyle(3, 0xffaa00);
          container.setScale(1.02);
        }
      }
    }

    const config = {
      type: Phaser.AUTO,
      width: 480,
      height: 520,
      backgroundColor: '#222222',
      parent: 'game-container',
      scene: [MenuScene, InstructionsScene, SlidingPuzzleScene]
    };

    new Phaser.Game(config);
  </script>
</body>

</html>